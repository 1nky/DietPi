#!/bin/bash
{
	#////////////////////////////////////
	# DietPi logclear Script
	#
	#////////////////////////////////////
	# Created by Dan Knight / daniel_haze@hotmail.com / fuzon.co.uk
	#
	#////////////////////////////////////
	#
	# Info:
	# - LOGCLEAR_MODE = -1 | Disabled.
	# - LOGCLEAR_MODE =  0 | Overwrites and clears all logs in /var/log - recursive
	# - LOGCLEAR_MODE =  1 | Updates the log file in /$HOME/log_backup/* . Then overwrites and clears all logs in /var/log - recursive
	#////////////////////////////////////
	
	TEMP_LOGLIST_FILEPATH="/tmp/logclear_temp"

	LOGCLEAR_MODE=$(cat /boot/dietpi.txt | grep 'logclear_mode_index=' | sed 's/logclear_mode_index=//g')
	
	#////////////////////////////////////
	# Run
	#////////////////////////////////////
	
	#----------------------------------------------------------------
	# NB: LOGCLEAR_MODE 0/1 in seperate forloops. Although they could all be in the same forloop, it would generate a "if (( $LOGCLEAR_MODE == ? ))" call for each log file.
	#MODE 0 | Clear all logs in /var/log by overwriting them.
	if (( $LOGCLEAR_MODE == 0 )); then

		#Find existing logs and read their filepath into an array
		find /var/log -type f > "$TEMP_LOGLIST_FILEPATH"
		readarray -t ARRAY_LOG_FILEPATH < "$TEMP_LOGLIST_FILEPATH"
		
		#Process Logfiles
		for ((i=0; i<${#ARRAY_LOG_FILEPATH[@]}; i++))
		do
			#Clear log files by overwriting them.
			echo -e "" > "${ARRAY_LOG_FILEPATH[$i]}"

		done
		
		#Remove temp files
		rm "$TEMP_LOGLIST_FILEPATH" &> /dev/null

		#delete[] array
		unset ARRAY_LOG_FILEPATH

	#----------------------------------------------------------------
	#MODE 1 = Add current log files data to /"$HOME"/logbackup/*. Then clear.
	elif (( $LOGCLEAR_MODE == 1 )); then

		#Find existing logs and read their filepath into an array
		find /var/log -type f > "$TEMP_LOGLIST_FILEPATH"
		readarray -t ARRAY_LOG_FILEPATH < "$TEMP_LOGLIST_FILEPATH"
		
		#Process Logfiles
		for ((i=0; i<${#ARRAY_LOG_FILEPATH[@]}; i++))
		do
			#Do we have any data to write? Check size of file.
			if (( $(stat -c%s "${ARRAY_LOG_FILEPATH[$i]}") > 1 )); then
			
				filename=$(echo -e ${ARRAY_LOG_FILEPATH[$i]} | sed 's/\/var\/log\///g')

				#Generate filepaths
				if [ ! -f "$HOME/logs_backup/$filename" ]; then

					#This is a little "hack" to automatically generate the required subdirectories.
					# EG: /this/is/my/logfile.txt | will create the folders /this/is/my
					#
					# How it works:
					# We create the target filepath as a folder
					# Then we delete the folder.
					# By doing this, we generate all the required subdirectories that the file needs.
					mkdir -p "$HOME/logs_backup/$filename"
					rm -R "$HOME/logs_backup/$filename"
				fi

				#Write current logfile contents to existing.
				cat "${ARRAY_LOG_FILEPATH[$i]}" >> "$HOME"/logs_backup/"$filename"
			fi
			
			#Clear log files by overwriting them.
			echo -e "" > "${ARRAY_LOG_FILEPATH[$i]}"

		done

		#Remove temp files
		rm "$TEMP_LOGLIST_FILEPATH" &> /dev/null

		#delete[] array
		unset ARRAY_LOG_FILEPATH
	fi

	#----------------------------------------------------------------
	exit
	#----------------------------------------------------------------
}